<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>So you want to implement Skeletal Animation | Crax’s thoughts on graphics and game dev</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="So you want to implement Skeletal Animation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is the first entry in a series of posts i’m doing about implementing Skeletal Animation. The introduction will be updated with links to the next posts" />
<meta property="og:description" content="This is the first entry in a series of posts i’m doing about implementing Skeletal Animation. The introduction will be updated with links to the next posts" />
<link rel="canonical" href="http://localhost:4000/rendering/engine/2025/02/02/skeletal-animations.html" />
<meta property="og:url" content="http://localhost:4000/rendering/engine/2025/02/02/skeletal-animations.html" />
<meta property="og:site_name" content="Crax’s thoughts on graphics and game dev" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-02-02T16:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="So you want to implement Skeletal Animation" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-02-02T16:00:00+01:00","datePublished":"2025-02-02T16:00:00+01:00","description":"This is the first entry in a series of posts i’m doing about implementing Skeletal Animation. The introduction will be updated with links to the next posts","headline":"So you want to implement Skeletal Animation","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/rendering/engine/2025/02/02/skeletal-animations.html"},"url":"http://localhost:4000/rendering/engine/2025/02/02/skeletal-animations.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/%20/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Crax&apos;s thoughts on graphics and game dev" /><link rel="stylesheet" href="/assets/css/syntax.css" />
</head><body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Crax&#39;s thoughts on graphics and game dev</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">So you want to implement Skeletal Animation</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-02-02T16:00:00+01:00" itemprop="datePublished">Feb 2, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This is the first entry in a series of posts i’m doing about implementing Skeletal Animation.
The introduction will be updated with links to the next posts</p>

<h3 id="small-but-needed-introduction-on-skeletal-animation">SMALL BUT NEEDED INTRODUCTION ON SKELETAL ANIMATION</h3>
<p>Video games are composed of multiple layers to immerse the player into their worlds: one of these layers (and imho one of the most important ones) is character animation.</p>

<p>One of the ways to bring our characters to life is through <em>Skeletal animation</em>: we attach a mesh’s vertices to a <em>skeleton</em>, which approximates the mesh: such meshes are called <strong>Skinned meshes</strong> (the opposite of a Skinned Mesh is often called Static Mesh).</p>

<p>The skeleton is usually handmade to suit the mesh through a process called <em>rigging</em>: after the character is modeled, the artist places some <em>bones</em> (or <em>joints</em>) on the mesh in a hierarchy, where the topmost bone (that is the one parent to them all) is called the skeleton’s <strong>root bone</strong>: the bones placed in this phase define the model’s <em>rest pose</em>, that is where the vertices lie when no animation is playing.</p>

<blockquote>
  <p>The reason the rest pose is important is that an artist might model a character in an A pose (with the arms pointing down), but, for ease of animation, the rest pose might be a T pose.</p>
</blockquote>

<p>INSERT SKELETON PIC</p>

<p>Each vertex in the mesh is then bound to one or more bones through a process called <em>weight painting</em>, where the artist “paints” on the mesh how much each bone influences a certain vertex (this process can also be automated, e.g through Blender’s <em>Automatic Weights</em> feature).</p>

<p>INSERT BLENDER WEIGHT PAINTING SCREEN</p>

<p>After all this is done, animations can be created: each animation is a group of <strong>key poses</strong>, which define the most important poses for the animation.
The key poses are then interpolated through one of more curves over a certain time span: these poses define for some of the skeleton’s bones their transform in 3D.
Sampling these curves results in a <em>Keyframe</em>, which is then applied to the mesh during rendering.</p>

<p>INSERT BLENDER ACTION EDITOR PIC</p>

<h3 id="getting-our-hands-dirty">GETTING OUR HANDS DIRTY</h3>
<p>Let’s start by defining a Static Mesh’s <code class="language-plaintext highlighter-rouge">Vertex</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vertex</span> <span class="p">{</span>
    <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">normal</span><span class="p">;</span>
    <span class="n">vec2</span> <span class="n">tex_coords</span><span class="p">;</span>
	
    <span class="n">vec3</span> <span class="n">tangent</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">bitangent</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>A Skinned Mesh is composed of Skinned Vertices (duh): a Skinned Vertex just extends our <code class="language-plaintext highlighter-rouge">Vertex</code> struct with two additional fields: one indicating which bones the vertex is influenced from, and another indicating how much the bone influences the vertex.</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SkinnedVertex</span> <span class="p">{</span>
    <span class="kt">vec3</span> <span class="n">position</span><span class="p">;</span>
    <span class="kt">vec3</span> <span class="n">normal</span><span class="p">;</span>
    <span class="kt">vec2</span> <span class="n">tex_coords</span><span class="p">;</span>
	
    <span class="kt">vec3</span> <span class="n">tangent</span><span class="p">;</span>
    <span class="kt">vec3</span> <span class="n">bitangent</span><span class="p">;</span>

    <span class="kt">ivec4</span> <span class="n">bone_ids</span><span class="p">;</span>
    <span class="kt">vec4</span> <span class="n">bone_weights</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>where the sum of <code class="language-plaintext highlighter-rouge">bone_weights</code> should equal to 1.</p>

<p>You can see that, with this definition, we’re limited to up to 4 bones per vertex: this is usually enough, and should suffice for most applications.</p>

<p>As we said earlier, we will be appling a specific <strong>Keyframe</strong> during rendering: what we mean is that the keyframe will contain for each bone a model space affine transform matrix for each bone, which we will use to transform each vertex.
For now, let’s assume that we got from some magic place an array of <code class="language-plaintext highlighter-rouge">mat4 bone_transforms</code> containing the keyframe’s bone transform matrices, and let’s define the set of operations needed to animate a Skinned Mesh.</p>

<p>The algorithm is very simple:</p>
<ol>
  <li>We fetch one of the Skinned Mesh’s vertices</li>
  <li>We iterate on the vertex’s influencing bone indices</li>
  <li>For each bone, we transform the vertex’s position with the bone transform, accumulating the positions.</li>
  <li>The accumulated position is the result of the skinning process</li>
</ol>

<p>My engine does something like this</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">mat4</span> <span class="n">bone_transforms</span><span class="p">[</span><span class="n">MAX_BONES</span><span class="p">];</span> <span class="c1">// the array of bone transforms</span>
<span class="k">struct</span> <span class="n">TransformedVertex</span> <span class="p">{</span>
	<span class="kt">vec3</span> <span class="n">position</span><span class="p">;</span>
	<span class="kt">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">TransformedVertex</span> <span class="nf">compute_skinned_position</span><span class="p">(</span><span class="n">SkinnedVertex</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">TransformedVertex</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_bones</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">is_invalid_bone_id</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">bone_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	
		<span class="kt">mat4</span> <span class="n">bone_transform</span> <span class="o">=</span> <span class="n">bone_transforms</span><span class="p">[</span><span class="n">v</span><span class="p">.</span><span class="n">bone_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
		<span class="n">s</span><span class="p">.</span><span class="n">position</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">bone_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">bone_transform</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">));</span>
		<span class="n">s</span><span class="p">.</span><span class="n">normal</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">bone_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">bone_transform</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">));</span>
	<span class="p">}</span>

  <span class="n">s</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span> <span class="c1">// Always remember to normalize any surface vector</span>

	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now, you’re probably wondering: how do we fill <code class="language-plaintext highlighter-rouge">bone_transforms</code>?</p>

<h3 id="dealing-with-transformations">DEALING WITH TRANSFORMATIONS</h3>
<p>When we rotate our arm, it makes sense to define how our arm rotates with respect to our shoulder: in the same way, we define our hand’s rotation w.r.t our forearm, which is then rotated w.r.t our arm, which is then rotated w.r.t our shoulder and so on, until we reach our spine (or, in the case of our mesh’s skeleton, the root bone).</p>

<p>Animatons work in the same way: for each keyframe, we know the bone’s <em>local transform</em> (expressed w.r.t the bone’s parent): in order to know each bone’s global transform, we need to multiply the bone’s local transform with the bone parent’s global transform.</p>

<p>Expressed in pseudocode, it’s something like this</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mat4</span> <span class="nf">global_transform</span><span class="p">(</span><span class="n">Bone</span> <span class="n">bone</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">bone</span> <span class="n">has</span> <span class="n">no</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bone</span><span class="p">.</span><span class="n">local_transform</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">bone</span><span class="p">.</span><span class="n">local_transform</span> <span class="o">*</span> <span class="n">global_transform</span><span class="p">(</span><span class="n">bone</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>A keen eye might noticed that with the pseudocode above we’re computing more matrix transformations than needed: we will deal with this issue in the next post.</p>
</blockquote>

<h4 id="the-inverse-bind-pose-matrix">THE INVERSE BIND POSE MATRIX</h4>
<p>Exceeeept… we’re not done yet.</p>

<p>Remember how we defined the mesh’s <em>rest pose</em> earlier? Yeah, that’s a transformation we need to account for.
When the rest pose is applied, all the vertices are transformed by the influencing bones’ <em>bind pose matrices</em>, to transform the bones from model space in bone local space.
That’s an issue, because in our applications we’re most likely working in model space: thus, we need to undo the bind pose transformation.
With all said, that’s very easy: the bind pose matrix is just another affine transformation matrix. We can then apply the inverted matrix, often called a bone’s <em>inverse pose matrix</em>, to the result of our <code class="language-plaintext highlighter-rouge">global_transform()</code> function:
Given a <code class="language-plaintext highlighter-rouge">Bone b</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bone_transforms</span><span class="p">[</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">bone</span><span class="p">.</span><span class="n">inverse_bind_pose</span> <span class="o">*</span> <span class="nf">global_transform</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</code></pre></div></div>

<p>The last remaining piece of the puzzle is reading the local transforms for each animation.</p>


  </div><a class="u-url" href="/rendering/engine/2025/02/02/skeletal-animations.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Crax&#39;s thoughts on graphics and game dev</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Crax&#39;s thoughts on graphics and game dev</li><li><a class="u-email" href="mailto:gsolimeno97@gmail.com">gsolimeno97@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Crax97"><svg
        class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#github"></use>
      </svg> <span class="username">Crax97</span></a></li><li><a
      href="https://gamedev.place/@mayoaddictrat"><svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#mastodon"></use>
      </svg> <span class="username">mayoaddictrat</span></a></li><li><a
      href="https://www.twitter.com/mayoaddictrat"><svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
      </svg> <span class="username">mayoaddictrat</span></a></li><li><a
      href="https://bsky.app/profile/mayoaddictrat.bsky.social"><svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#tbluesky"></use>
      </svg> <span class="username">mayoaddictrat</span></a></li></ul></div>

      <div class="footer-col footer-col-3">
        <p>Random thougths and notes about graphics programming, game dev and in general CS stuff</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
